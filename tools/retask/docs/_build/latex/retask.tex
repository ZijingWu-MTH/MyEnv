% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{retask Documentation}
\date{July 09, 2013}
\release{0.4}
\author{Kushal Das}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\def\PYG@tok@gd{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\def\PYG@tok@gu{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\def\PYG@tok@gt{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.25,0.82}{##1}}}
\def\PYG@tok@gs{\let\PYG@bf=\textbf}
\def\PYG@tok@gr{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\def\PYG@tok@cm{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@vg{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@m{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mh{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@cs{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\colorbox[rgb]{1.00,0.94,0.94}{##1}}}
\def\PYG@tok@ge{\let\PYG@it=\textit}
\def\PYG@tok@vc{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@il{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@go{\def\PYG@tc##1{\textcolor[rgb]{0.19,0.19,0.19}{##1}}}
\def\PYG@tok@cp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@gi{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\def\PYG@tok@gh{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\def\PYG@tok@ni{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\def\PYG@tok@nl{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\def\PYG@tok@nn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@no{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\def\PYG@tok@na{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@nb{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@nd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\def\PYG@tok@ne{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nf{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\def\PYG@tok@si{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\def\PYG@tok@s2{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@vi{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@nt{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\def\PYG@tok@nv{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@s1{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@gp{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@sh{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@ow{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@sx{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@bp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c1{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@kc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@mf{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@err{\def\PYG@bc##1{\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{##1}}}
\def\PYG@tok@kd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@ss{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\def\PYG@tok@sr{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\def\PYG@tok@mo{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mi{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@kn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@o{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\def\PYG@tok@kr{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@s{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@kp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@w{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\def\PYG@tok@kt{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\def\PYG@tok@sc{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sb{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@k{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@se{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sd{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


retask is a python module to create and manage distributed task queue/job queue.

It uses \href{http://redis.io}{Redis} to create task queues. User can enqueue
and dequeue tasks in the queues they manage. Each task can contain any JSON
serializable python objects. We use \emph{JSON} internally to store the tasks
in the queues.

Workers can execute tasks and return the result asynchronously and if required
synchronously (wait until worker returns the result to the job).


\chapter{Dependencies}
\label{index:dependencies}\label{index:retask-simple-task-queue}\begin{itemize}
\item {} 
python-redis

\item {} 
mock

\item {} 
A running Redis server

\end{itemize}


\chapter{User Guide}
\label{index:user-guide}

\section{Introduction}
\label{user/intro:introduction}\label{user/intro::doc}\label{user/intro:id1}

\subsection{First requirement}
\label{user/intro:first-requirement}
For various others projects I had to start looking for a
simple task queue and solve kind of classical producer-consumer problems
using them.

This project started from that idea.


\subsection{Why Redis}
\label{user/intro:why-redis}
I am following \href{http://redis.io}{Redis}  development for a long time and using
it in various other projects. The simplicity it provides and rich datastructures
are always a plus to use it.

Redis takes care of multithreading issues, it also helps to have data on disk for
data persistence. It does not have any external dependencies and also very small
in size, which helps to be used in enterprise world.


\subsection{Retask License}
\label{user/intro:retask-license}
Copyright (C) 2012, Kushal Das

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the ``Software''), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


\section{Setting up the Redis Server}
\label{user/redis::doc}\label{user/redis:setting-up-the-redis-server}
You can download and install \href{http://redis.io}{Redis} on your distro.

In \href{http://fedoraproject.org}{Fedora} you can just \code{yum install redis}
for the same.

To start the server in the local folder use the following command:

\begin{Verbatim}[commandchars=\\\{\}]
\$ redis-server
\end{Verbatim}

On Fedora you can start the service as \emph{root}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} systemctl enable redis.service}
\PYG{c}{\PYGZsh{} systemctl start redis.service}
\end{Verbatim}

In \href{http://debian.org}{Debian} just install the redis-server package with
\code{apt-get install redis-server} to have a redis server running.


\section{Installation}
\label{user/install:installation}\label{user/install::doc}\label{user/install:install}
This part of the documentation covers the installation of Retask.
The first step to using any software package is getting it properly installed.


\subsection{Distribute \& Pip}
\label{user/install:distribute-pip}
Installing requests is simple with \href{http://www.pip-installer.org/}{pip}:

\begin{Verbatim}[commandchars=\\\{\}]
\$ pip install retask
\end{Verbatim}

or, with \href{http://pypi.python.org/pypi/setuptools}{easy\_install}:

\begin{Verbatim}[commandchars=\\\{\}]
\$ easy\_install retask
\end{Verbatim}

But, you really \href{http://www.pip-installer.org/en/latest/other-tools.html\#pip-compared-to-easy-install}{shouldn't do that}.


\subsection{Get the Code}
\label{user/install:get-the-code}
Retask is actively developed on GitHub, where the code is
\href{https://github.com/kushaldas/retask}{always available}.

You can either clone the public repository:

\begin{Verbatim}[commandchars=\\\{\}]
git clone git://github.com/kushaldas/retask.git
\end{Verbatim}

Download the \href{https://github.com/kushaldas/retask/tarball/master}{tarball}:

\begin{Verbatim}[commandchars=\\\{\}]
\$ curl -OL https://github.com/kushaldas/retask/tarball/master
\end{Verbatim}

Or, download the \href{https://github.com/kushaldas/retask/zipball/master}{zipball}:

\begin{Verbatim}[commandchars=\\\{\}]
\$ curl -OL https://github.com/kushaldas/retask/tarball/master
\end{Verbatim}

Once you have a copy of the source, you can embed it in your Python package,
or install it into your site-packages easily:

\begin{Verbatim}[commandchars=\\\{\}]
\$ python setup.py install
\end{Verbatim}


\subsection{Installing redis-py}
\label{user/install:installing-redis-py}\label{user/install:redis}
You can install \code{redis-py} with \code{pip}:

\begin{Verbatim}[commandchars=\\\{\}]
\$ pip install redis
\end{Verbatim}


\section{Quickstart}
\label{user/quickstart::doc}\label{user/quickstart:quickstart}\label{user/quickstart:id1}
For this example to work you should have your redis instance
up and running.


\subsection{producer.py}
\label{user/quickstart:producer-py}
This code puts new task in the queue. We will have a dictionary as
the information in this example.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{retask} \PYG{k+kn}{import} \PYG{n}{Task}
\PYG{k+kn}{from} \PYG{n+nn}{retask} \PYG{k+kn}{import} \PYG{n}{Queue}
\PYG{n}{queue} \PYG{o}{=} \PYG{n}{Queue}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{example}\PYG{l+s}{'}\PYG{p}{)}
\PYG{n}{info1} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s}{'}\PYG{l+s}{user}\PYG{l+s}{'}\PYG{p}{:}\PYG{l+s}{'}\PYG{l+s}{kushal}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{url}\PYG{l+s}{'}\PYG{p}{:}\PYG{l+s}{'}\PYG{l+s}{http://kushaldas.in}\PYG{l+s}{'}\PYG{p}{\PYGZcb{}}
\PYG{n}{info2} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s}{'}\PYG{l+s}{user}\PYG{l+s}{'}\PYG{p}{:}\PYG{l+s}{'}\PYG{l+s}{fedora planet}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{url}\PYG{l+s}{'}\PYG{p}{:}\PYG{l+s}{'}\PYG{l+s}{http://planet.fedoraproject.org}\PYG{l+s}{'}\PYG{p}{\PYGZcb{}}
\PYG{n}{task1} \PYG{o}{=} \PYG{n}{Task}\PYG{p}{(}\PYG{n}{info1}\PYG{p}{)}
\PYG{n}{task2} \PYG{o}{=} \PYG{n}{Task}\PYG{p}{(}\PYG{n}{info2}\PYG{p}{)}
\PYG{n}{queue}\PYG{o}{.}\PYG{n}{connect}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{queue}\PYG{o}{.}\PYG{n}{enqueue}\PYG{p}{(}\PYG{n}{task1}\PYG{p}{)}
\PYG{n}{queue}\PYG{o}{.}\PYG{n}{enqueue}\PYG{p}{(}\PYG{n}{task2}\PYG{p}{)}
\end{Verbatim}


\subsection{consumer.py}
\label{user/quickstart:consumer-py}
This code gets the tasks from the queue. Based on the actual requirement, the
client will work on the information it received as the task. For now we will
just print the data.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{retask} \PYG{k+kn}{import} \PYG{n}{Task}
\PYG{k+kn}{from} \PYG{n+nn}{retask} \PYG{k+kn}{import} \PYG{n}{Queue}
\PYG{n}{queue} \PYG{o}{=} \PYG{n}{Queue}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{example}\PYG{l+s}{'}\PYG{p}{)}
\PYG{n}{queue}\PYG{o}{.}\PYG{n}{connect}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{while} \PYG{n}{queue}\PYG{o}{.}\PYG{n}{length} \PYG{o}{!=} \PYG{l+m+mi}{0}\PYG{p}{:}
    \PYG{n}{task} \PYG{o}{=} \PYG{n}{queue}\PYG{o}{.}\PYG{n}{dequeue}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{task}\PYG{p}{:}
        \PYG{k}{print} \PYG{n}{task}\PYG{o}{.}\PYG{n}{data}
\end{Verbatim}


\section{Tutorials}
\label{user/tutorials:tutorials}\label{user/tutorials::doc}\label{user/tutorials:id1}
This section of the document we have in depth examples of various use cases.


\subsection{Async data transfer between producer and worker}
\label{user/tutorials:async-data-transfer-between-producer-and-worker}
In many real life scenarios we need to send the result back from the worker instances
to the producer. The following code examples shows how to achieve that.


\subsubsection{async\_producer.py}
\label{user/tutorials:async-producer-py}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{retask} \PYG{k+kn}{import} \PYG{n}{Task}
\PYG{k+kn}{from} \PYG{n+nn}{retask} \PYG{k+kn}{import} \PYG{n}{Queue}
\PYG{k+kn}{import} \PYG{n+nn}{time}
\PYG{n}{queue} \PYG{o}{=} \PYG{n}{Queue}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{example}\PYG{l+s}{'}\PYG{p}{)}
\PYG{n}{info1} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s}{'}\PYG{l+s}{user}\PYG{l+s}{'}\PYG{p}{:} \PYG{l+s}{'}\PYG{l+s}{Fedora planet}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{url}\PYG{l+s}{'}\PYG{p}{:} \PYG{l+s}{'}\PYG{l+s}{http://planet.fedoraproject.org}\PYG{l+s}{'}\PYG{p}{\PYGZcb{}}
\PYG{n}{task1} \PYG{o}{=} \PYG{n}{Task}\PYG{p}{(}\PYG{n}{info1}\PYG{p}{)}
\PYG{n}{queue}\PYG{o}{.}\PYG{n}{connect}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{job} \PYG{o}{=} \PYG{n}{queue}\PYG{o}{.}\PYG{n}{enqueue}\PYG{p}{(}\PYG{n}{task1}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{job}\PYG{o}{.}\PYG{n}{result}
\PYG{n}{time}\PYG{o}{.}\PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{job}\PYG{o}{.}\PYG{n}{result}
\end{Verbatim}

Here queue.enqueue method returns a {\hyperref[retask.queue:retask.queue.Job]{\code{Job}}} object. We can access job.result
to see returned result from a worker. If there is no result yet came back from the worker, it will
print \emph{None}. If you don't need any returned data from the worker you can safely ignore the job object.


\subsubsection{async\_consumer.py}
\label{user/tutorials:async-consumer-py}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{retask} \PYG{k+kn}{import} \PYG{n}{Task}
\PYG{k+kn}{from} \PYG{n+nn}{retask} \PYG{k+kn}{import} \PYG{n}{Queue}
\PYG{k+kn}{import} \PYG{n+nn}{time}
\PYG{n}{queue} \PYG{o}{=} \PYG{n}{Queue}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{example}\PYG{l+s}{'}\PYG{p}{)}
\PYG{n}{queue}\PYG{o}{.}\PYG{n}{connect}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{task} \PYG{o}{=} \PYG{n}{queue}\PYG{o}{.}\PYG{n}{wait}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{task}\PYG{o}{.}\PYG{n}{data}
\PYG{n}{time}\PYG{o}{.}\PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mi}{15}\PYG{p}{)}
\PYG{n}{queue}\PYG{o}{.}\PYG{n}{send}\PYG{p}{(}\PYG{n}{task}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{We received your information dear }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{"} \PYG{o}{\PYGZpc{}} \PYG{n}{task}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{user}\PYG{l+s}{'}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

In the above example we see two newly introduced methods {\hyperref[retask.queue:retask.queue.Queue]{\code{Queue}}}.
{\hyperref[retask.queue:retask.queue.Queue.wait]{\code{wait()}}} is a blocking call to wait for a new task in the queue. This is
the preferred method over polling using {\hyperref[retask.queue:retask.queue.Queue.dequeue]{\code{dequeue()}}}.
To send the result back workers will use {\hyperref[retask.queue:retask.queue.Queue.send]{\code{send()}}} method, which takes an optional argument
\emph{wait\_time} to specify timeout value in seconds.


\subsection{Synchronous / blocking wait for the result}
\label{user/tutorials:synchronous-blocking-wait-for-the-result}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{retask} \PYG{k+kn}{import} \PYG{n}{Task}
\PYG{k+kn}{from} \PYG{n+nn}{retask} \PYG{k+kn}{import} \PYG{n}{Queue}
\PYG{n}{queue} \PYG{o}{=} \PYG{n}{Queue}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{example}\PYG{l+s}{'}\PYG{p}{)}
\PYG{n}{info1} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s}{'}\PYG{l+s}{user}\PYG{l+s}{'}\PYG{p}{:} \PYG{l+s}{'}\PYG{l+s}{Fedora planet}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{url}\PYG{l+s}{'}\PYG{p}{:} \PYG{l+s}{'}\PYG{l+s}{http://planet.fedoraproject.org}\PYG{l+s}{'}\PYG{p}{\PYGZcb{}}
\PYG{n}{task1} \PYG{o}{=} \PYG{n}{Task}\PYG{p}{(}\PYG{n}{info1}\PYG{p}{)}
\PYG{n}{queue}\PYG{o}{.}\PYG{n}{connect}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{job} \PYG{o}{=} \PYG{n}{queue}\PYG{o}{.}\PYG{n}{enqueue}\PYG{p}{(}\PYG{n}{task1}\PYG{p}{)}
\PYG{n}{job}\PYG{o}{.}\PYG{n}{wait}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{job}\PYG{o}{.}\PYG{n}{result}
\end{Verbatim}

In this example we are using {\hyperref[retask.queue:retask.queue.Job.wait]{\code{wait()}}} function to do a blocking
synchronous call to the worker.


\chapter{API Documentation}
\label{index:api-documentation}

\section{API}
\label{api:api}\label{api::doc}\label{api:id1}\phantomsection\label{api:module-retask}\index{retask (module)}
This part contains the API documentation of the module.


\subsection{Submodules}
\label{api:submodules}

\subsubsection{\texttt{retask.queue}}
\label{retask.queue::doc}\label{retask.queue:retask-queue}
This module contains the primary \code{Queue} which
can be used to create and manage queues.
\index{Queue (class in retask.queue)}

\begin{fulllineitems}
\phantomsection\label{retask.queue:retask.queue.Queue}\pysiglinewithargsret{\strong{class }\code{retask.queue.}\bfcode{Queue}}{\emph{name}, \emph{config=None}}{}
Returns the \code{Queue} object with the given name. If the user
passes optional config dictionary with details for Redis
server, it will connect to that instance. By default it connects
to the localhost.
\index{connect() (retask.queue.Queue method)}

\begin{fulllineitems}
\phantomsection\label{retask.queue:retask.queue.Queue.connect}\pysiglinewithargsret{\bfcode{connect}}{}{}
Creates the connection with the redis server.
Return \code{True} if the connection works, else returns
\code{False}. It does not take any arguments.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\code{Boolean} value

\end{description}\end{quote}

\begin{notice}{note}{Note:}
After creating the \code{Queue} object the user should call
the \code{connect} method to create the connection.
\end{notice}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{retask} \PYG{k+kn}{import} \PYG{n}{Queue}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{q} \PYG{o}{=} \PYG{n}{Queue}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{test}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{q}\PYG{o}{.}\PYG{n}{connect}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{True}
\end{Verbatim}

\end{fulllineitems}

\index{dequeue() (retask.queue.Queue method)}

\begin{fulllineitems}
\phantomsection\label{retask.queue:retask.queue.Queue.dequeue}\pysiglinewithargsret{\bfcode{dequeue}}{}{}
Returns a \code{Task} object from the queue. Returns \code{None} if the
queue is empty.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\code{Task} object from the queue

\end{description}\end{quote}

If the queue is not connected then it will raise
{\hyperref[api:retask.ConnectionError]{\code{retask.ConnectionError}}}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{retask} \PYG{k+kn}{import} \PYG{n}{Queue}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{q} \PYG{o}{=} \PYG{n}{Queue}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{test}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{q}\PYG{o}{.}\PYG{n}{connect}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{True}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{t} \PYG{o}{=} \PYG{n}{q}\PYG{o}{.}\PYG{n}{dequeue}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{t}\PYG{o}{.}\PYG{n}{data}
\PYG{g+go}{\PYGZob{}u'name': u'kushal'\PYGZcb{}}
\end{Verbatim}

\end{fulllineitems}

\index{enqueue() (retask.queue.Queue method)}

\begin{fulllineitems}
\phantomsection\label{retask.queue:retask.queue.Queue.enqueue}\pysiglinewithargsret{\bfcode{enqueue}}{\emph{task}}{}
Enqueues the given \code{Task} object to the queue and returns
a {\hyperref[retask.queue:retask.queue.Job]{\code{Job}}} object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{task} -- :\code{Task} object

\item[{Returns}] \leavevmode
{\hyperref[retask.queue:retask.queue.Job]{\code{Job}}} object

\end{description}\end{quote}

If the queue is not connected then it will raise
{\hyperref[api:retask.ConnectionError]{\code{retask.ConnectionError}}}.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{retask} \PYG{k+kn}{import} \PYG{n}{Queue}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{q} \PYG{o}{=} \PYG{n}{Queue}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{test}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{q}\PYG{o}{.}\PYG{n}{connect}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{True}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{retask.task} \PYG{k+kn}{import} \PYG{n}{Task}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{task} \PYG{o}{=} \PYG{n}{Task}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s}{'}\PYG{l+s}{name}\PYG{l+s}{'}\PYG{p}{:}\PYG{l+s}{'}\PYG{l+s}{kushal}\PYG{l+s}{'}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{job} \PYG{o}{=} \PYG{n}{q}\PYG{o}{.}\PYG{n}{enqueue}\PYG{p}{(}\PYG{n}{task}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{find() (retask.queue.Queue method)}

\begin{fulllineitems}
\phantomsection\label{retask.queue:retask.queue.Queue.find}\pysiglinewithargsret{\bfcode{find}}{\emph{obj}}{}
Returns the index of the given object in the queue, it might be string
which will be searched inside each task.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{obj} -- object we are looking

\item[{Returns}] \leavevmode
-1 if the object is not found or else the location of the task

\end{description}\end{quote}

\end{fulllineitems}

\index{length (retask.queue.Queue attribute)}

\begin{fulllineitems}
\phantomsection\label{retask.queue:retask.queue.Queue.length}\pysigline{\bfcode{length}}
Gives the length of the queue. Returns \code{None} if the queue is not
connected.

If the queue is not connected then it will raise
{\hyperref[api:retask.ConnectionError]{\code{retask.ConnectionError}}}.

\end{fulllineitems}

\index{send() (retask.queue.Queue method)}

\begin{fulllineitems}
\phantomsection\label{retask.queue:retask.queue.Queue.send}\pysiglinewithargsret{\bfcode{send}}{\emph{task}, \emph{result}, \emph{expire=60}}{}
Sends the result back to the producer. This should be called if only you
want to return the result in async manner.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{task} -- :\code{Task} object

\item {} 
\textbf{result} -- Result data to be send back. Should be in JSON serializable.

\item {} 
\textbf{expire} -- Time in seconds after the key expires. Default is 60 seconds.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{wait() (retask.queue.Queue method)}

\begin{fulllineitems}
\phantomsection\label{retask.queue:retask.queue.Queue.wait}\pysiglinewithargsret{\bfcode{wait}}{\emph{wait\_time=0}}{}
Returns a \code{Task} object from the queue. Returns \code{False} if it timeouts.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{wait\_time} -- Time in seconds to wait, default is infinite.

\item[{Returns}] \leavevmode
\code{Task} object from the queue or False if it timeouts.

\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{retask} \PYG{k+kn}{import} \PYG{n}{Queue}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{q} \PYG{o}{=} \PYG{n}{Queue}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{test}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{q}\PYG{o}{.}\PYG{n}{connect}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{True}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{task} \PYG{o}{=} \PYG{n}{q}\PYG{o}{.}\PYG{n}{wait}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{task}\PYG{o}{.}\PYG{n}{data}
\PYG{g+go}{\PYGZob{}u'name': u'kushal'\PYGZcb{}}
\end{Verbatim}

\begin{notice}{note}{Note:}
This is a blocking call, you can specity wait\_time argument for timeout.
\end{notice}

\end{fulllineitems}


\end{fulllineitems}

\index{Job (class in retask.queue)}

\begin{fulllineitems}
\phantomsection\label{retask.queue:retask.queue.Job}\pysiglinewithargsret{\strong{class }\code{retask.queue.}\bfcode{Job}}{\emph{rdb}}{}
Job object containing the result from the workers.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{rdb} -- The underlying redis connection.

\end{description}\end{quote}
\index{result (retask.queue.Job attribute)}

\begin{fulllineitems}
\phantomsection\label{retask.queue:retask.queue.Job.result}\pysigline{\bfcode{result}}
Returns the result from the worker for this job. This is used to pass
result in async way.

\end{fulllineitems}

\index{wait() (retask.queue.Job method)}

\begin{fulllineitems}
\phantomsection\label{retask.queue:retask.queue.Job.wait}\pysiglinewithargsret{\bfcode{wait}}{\emph{wait\_time=0}}{}
Blocking call to check if the worker returns the result. One can use
job.result after this call returns \code{True}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{wait\_time} -- Time in seconds to wait, default is infinite.

\item[{Returns}] \leavevmode
\emph{True} or \emph{False}.

\end{description}\end{quote}

\begin{notice}{note}{Note:}
This is a blocking call, you can specity wait\_time argument for timeout.
\end{notice}

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{\texttt{retask.task}}
\label{retask.task:retask-task}\label{retask.task::doc}
This module conatins generic task class, which can be used to create
any kind of given task with serializable python objects as data.
\index{retask.Task (built-in class)}

\begin{fulllineitems}
\phantomsection\label{retask.task:retask.Task}\pysiglinewithargsret{\strong{class }\code{retask.}\bfcode{Task}}{\emph{data=None}, \emph{raw=False}}{}~\begin{quote}

Returns a new Task object, the information for the task is passed through argument \emph{data}.
\end{quote}
\index{data (retask.Task attribute)}

\begin{fulllineitems}
\phantomsection\label{retask.task:retask.Task.data}\pysigline{\bfcode{data}}
The python object containing information for the current task

\end{fulllineitems}


\end{fulllineitems}



\subsection{Exceptions}
\label{api:exceptions}\index{RetaskException}

\begin{fulllineitems}
\phantomsection\label{api:retask.RetaskException}\pysigline{\strong{exception }\code{retask.}\bfcode{RetaskException}}
Some ambiguous exception occurred

\end{fulllineitems}

\index{ConnectionError}

\begin{fulllineitems}
\phantomsection\label{api:retask.ConnectionError}\pysigline{\strong{exception }\code{retask.}\bfcode{ConnectionError}}
A Connection error occurred.

\end{fulllineitems}



\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{r}
\item {\texttt{retask}}, \pageref{api:module-retask}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
